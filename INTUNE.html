<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Microsoft Intune Object Model Visualization</title>

  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #1a202c;
      color: #e2e8f0;
      font-family: sans-serif;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    #root {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .visualization-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .diagram-container {
      flex: 3;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .details-panel {
      flex: 1;
      border-left: 1px solid #374151;
      padding: 1rem;
      overflow-y: auto;
      min-width: 200px;
      background-color: #1f2937;
    }

    .svg-container {
      flex: 1;
      min-height: 0;
      border: 1px solid #374151;
      border-radius: 0.5rem;
      background-color: #374151;
      overflow: hidden;
    }

    .list-view-container {
      flex: 1;
      min-height: 0;
      border: 1px solid #374151;
      border-radius: 0.5rem;
      background-color: #1f2937;
      overflow-y: auto;
      padding: 0.5rem;
    }

    .controls-container {
      padding: 1rem;
      flex-shrink: 0;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function IntuneObjectMap() {
      // State management
      const [view, setView] = useState('diagram'); // diagram or list
      const [activeLayers, setActiveLayers] = useState(['core']);
      const [focusedNode, setFocusedNode] = useState(null);
      const [selectedObject, setSelectedObject] = useState(null);
      const [showRelationshipDetails, setShowRelationshipDetails] = useState(false);
      
      // SVG ref for d3 visualization
      const svgRef = useRef(null);
      
      // Define main components/nodes of the Intune object model
      const nodes = [
        { id: 'users', name: 'Users', category: 'core', description: 'Individual users from Microsoft Entra ID' },
        { id: 'devices', name: 'Devices', category: 'core', description: 'Managed devices (phones, tablets, PCs)' },
        { id: 'groups', name: 'Groups', category: 'core', description: 'Logical containers for users and devices' },
        { id: 'policies', name: 'Policies', category: 'core', description: 'Settings and rules for device management' },
        { id: 'applications', name: 'Applications', category: 'core', description: 'Software deployed to devices' },
        { id: 'configurations', name: 'Configurations', category: 'core', description: 'Device configuration profiles for various settings' },
        { id: 'assignmentFilters', name: 'Assignment Filters', category: 'core', description: 'Rules that refine policy and app assignments' },
        { id: 'adminRoles', name: 'Admin Roles', category: 'admin', description: 'Permissions for Intune administrators' },
        { id: 'scopeTags', name: 'Scope Tags', category: 'admin', description: 'Control administrative visibility and RBAC' },
        { id: 'deviceCategories', name: 'Device Categories', category: 'device', description: 'Categorization for management (e.g., Corporate, BYOD)' },
        { id: 'deviceOwnership', name: 'Device Ownership', category: 'device', description: 'Defines if device is personal or corporate' },
        { id: 'deploymentProfiles', name: 'Deployment Profiles', category: 'device', description: 'Settings for deployment scenarios' },
        { id: 'devicePlatforms', name: 'Device Platforms', category: 'device', description: 'OS platforms (Windows, iOS, Android, macOS)' },
        { id: 'complianceStates', name: 'Compliance States', category: 'compliance', description: 'Device compliance status' },
        { id: 'conditionalAccess', name: 'Conditional Access', category: 'compliance', description: 'Access control based on conditions' },
        { id: 'termsOfUse', name: 'Terms of Use', category: 'compliance', description: 'Agreements users must accept' },
        { id: 'scripts', name: 'Scripts', category: 'remediation', description: 'PowerShell scripts for device configuration' },
        { id: 'remediations', name: 'Remediations', category: 'remediation', description: 'Proactive remediation scripts for detection and fixing issues' },
        { id: 'shellScripts', name: 'Shell Scripts', category: 'remediation', description: 'Shell scripts for macOS management' },
        { id: 'policyLifecycle', name: 'Policy Lifecycle', category: 'admin', description: 'Backup, versioning and restore of policies' },
        { id: 'tenantAdmin', name: 'Tenant Admin', category: 'admin', description: 'Tenant-wide settings and configurations' },
        { id: 'notification', name: 'Notifications', category: 'admin', description: 'Alerts and notifications configuration' },
        { id: 'dataWarehouse', name: 'Data Warehouse', category: 'api', description: 'Historical Intune data' },
        { id: 'graphAPI', name: 'Graph API', category: 'api', description: 'Programmatic access to Intune' },
        { id: 'reporting', name: 'Reporting', category: 'api', description: 'Built-in and custom reports' }
      ];
      
      // Define relationships (connections) between components
      const links = [
        { 
          source: 'users', 
          target: 'groups', 
          type: 'belongs to', 
          description: 'Users belong to groups for management purposes',
          details: 'Users can be placed in static groups (direct assignment) or dynamic groups (based on attributes)',
          mechanism: 'Membership defined in Microsoft Entra ID and synchronized to Intune'
        },
        { 
          source: 'users', 
          target: 'devices', 
          type: 'associated with', 
          description: 'Users are associated with devices they enroll',
          details: 'A single user can have multiple devices; devices can have a primary user',
          mechanism: 'User Principal Name (UPN) links Intune device object to Entra ID user object'
        },
        { 
          source: 'devices', 
          target: 'groups', 
          type: 'belongs to', 
          description: 'Devices belong to groups for targeting',
          details: 'Devices can be in static or dynamic groups based on properties',
          mechanism: 'Dynamic groups use queries against device attributes (OS, ownership, etc.)'
        },
        { 
          source: 'policies', 
          target: 'groups', 
          type: 'assigned to', 
          description: 'Policies target specific groups of users/devices',
          details: 'Assignment determines which policies apply to which objects',
          mechanism: 'When a device checks in, it receives policies based on its group memberships'
        },
        { 
          source: 'policies', 
          target: 'assignmentFilters', 
          type: 'refined by', 
          description: 'Assignment filters refine policy targeting',
          details: 'Allows more granular targeting beyond group membership',
          mechanism: 'Applies additional rules based on device properties to include/exclude devices'
        },
        { 
          source: 'applications', 
          target: 'assignmentFilters', 
          type: 'refined by', 
          description: 'Assignment filters refine app targeting',
          details: 'Allows targeting apps based on device properties',
          mechanism: 'Evaluates device attributes beyond group membership during deployment'
        },
        { 
          source: 'configurations', 
          target: 'groups', 
          type: 'assigned to', 
          description: 'Configuration profiles target specific groups',
          details: 'Controls device settings based on platform and purpose',
          mechanism: 'Device processes configurations during check-in based on assignments'
        },
        { 
          source: 'applications', 
          target: 'groups', 
          type: 'assigned to', 
          description: 'Apps are deployed to specific groups',
          details: 'Apps can be required, available, or set to uninstall',
          mechanism: 'Intune Management Extension handles Win32 app deployment'
        },
        { 
          source: 'policies', 
          target: 'complianceStates', 
          type: 'determines', 
          description: 'Compliance policies define requirements',
          details: 'Devices are evaluated against policies to determine compliance',
          mechanism: 'Devices report status to Intune, which evaluates against policy requirements'
        },
        { 
          source: 'devices', 
          target: 'complianceStates', 
          type: 'has', 
          description: 'Each device has a compliance state',
          details: 'Compliance state can be Compliant, NonCompliant, etc.',
          mechanism: 'Determined by evaluating device properties against compliance policies'
        },
        { 
          source: 'complianceStates', 
          target: 'conditionalAccess', 
          type: 'used by', 
          description: 'Compliance states inform access decisions',
          details: 'Only compliant devices can access corporate resources',
          mechanism: 'Entra ID Conditional Access consumes Intune compliance data for access decisions'
        },
        { 
          source: 'scopeTags', 
          target: 'policies', 
          type: 'restricts access to', 
          description: 'Controls which admins can see and modify policies',
          details: 'Admins only see objects with matching scope tags assigned to their role',
          mechanism: 'Core component of Role-Based Access Control (RBAC) model for administrative delegation'
        },
        { 
          source: 'scopeTags', 
          target: 'configurations', 
          type: 'restricts access to', 
          description: 'Controls which admins can see and modify configuration profiles',
          details: 'Limits configuration visibility to admins with matching scope tags',
          mechanism: 'Enforces administrative boundaries in shared Intune environments'
        },
        { 
          source: 'scopeTags', 
          target: 'applications', 
          type: 'restricts access to', 
          description: 'Controls which admins can see and modify applications',
          details: 'Prevents unauthorized administrators from modifying applications',
          mechanism: 'Supports departmental or regional administration models'
        },
        { 
          source: 'scopeTags', 
          target: 'scripts', 
          type: 'restricts access to', 
          description: 'Controls which admins can see and modify PowerShell scripts',
          details: 'Prevents unauthorized administrators from modifying scripts',
          mechanism: 'Critical for securing administrative access to powerful scripting capabilities'
        },
        { 
          source: 'adminRoles', 
          target: 'users', 
          type: 'assigned to', 
          description: 'Admin roles define permissions',
          details: 'Controls what actions administrators can perform',
          mechanism: 'Based on role-based access control (RBAC) principles'
        },
        { 
          source: 'deviceCategories', 
          target: 'devices', 
          type: 'categorizes', 
          description: 'Organizes devices into categories',
          details: 'Categories can be used in group membership rules',
          mechanism: 'Assigned during enrollment or by administrators'
        },
        { 
          source: 'deploymentProfiles', 
          target: 'devices', 
          type: 'configures', 
          description: 'Defines deployment settings for devices',
          details: 'Used for scenarios like Windows Autopilot',
          mechanism: 'Applied during device provisioning process'
        },
        { 
          source: 'configurations', 
          target: 'devices', 
          type: 'configures', 
          description: 'Applies settings to devices',
          details: 'Controls various aspects of device functionality and security',
          mechanism: 'Settings enforced by MDM protocols based on device platform'
        },
        { 
          source: 'scripts', 
          target: 'devices', 
          type: 'runs on', 
          description: 'PowerShell scripts execute on devices',
          details: 'Provides custom configuration and management capabilities',
          mechanism: 'Delivered and executed by the Intune Management Extension'
        },
        { 
          source: 'remediations', 
          target: 'devices', 
          type: 'monitors and fixes', 
          description: 'Proactively finds and resolves issues',
          details: 'Detection script identifies issues, remediation script fixes them',
          mechanism: 'Scheduled execution via Intune Management Extension with reporting'
        },
        { 
          source: 'applications', 
          target: 'devices', 
          type: 'deployed to', 
          description: 'Applications installed on devices',
          details: 'Applications delivered based on group assignments',
          mechanism: 'Various deployment methods based on app and platform type'
        },
        { 
          source: 'policyLifecycle', 
          target: 'policies', 
          type: 'manages', 
          description: 'Handles versioning and backups of policies',
          details: 'Enables rollback and version comparison',
          mechanism: 'Creates policy snapshots that can be restored when needed'
        },
        { 
          source: 'policyLifecycle', 
          target: 'configurations', 
          type: 'manages', 
          description: 'Handles versioning of configurations',
          details: 'Tracks changes to configuration profiles over time',
          mechanism: 'Stores snapshots of configurations for restore operations'
        },
        { 
          source: 'tenantAdmin', 
          target: 'scopeTags', 
          type: 'manages', 
          description: 'Controls scope tag definitions',
          details: 'Creates and assigns scope tags across the tenant',
          mechanism: 'Central administration of RBAC components'
        },
        { 
          source: 'tenantAdmin', 
          target: 'adminRoles', 
          type: 'manages', 
          description: 'Controls role definitions and assignments',
          details: 'Defines custom roles and permissions',
          mechanism: 'Central administration of RBAC components'
        },
        { 
          source: 'graphAPI', 
          target: 'dataWarehouse', 
          type: 'accesses', 
          description: 'API provides access to Intune data',
          details: 'Enables programmatic reporting and automation',
          mechanism: 'OData endpoint with JSON responses'
        },
        { 
          source: 'graphAPI', 
          target: 'tenantAdmin', 
          type: 'manages', 
          description: 'API enables tenant-wide changes',
          details: 'Allows script-based administration of Intune',
          mechanism: 'REST API endpoints for all administrative functions'
        },
        { 
          source: 'deviceOwnership', 
          target: 'devices', 
          type: 'classifies', 
          description: 'Defines if a device is corporate or personal',
          details: 'Critical attribute for policy decisions and compliance requirements',
          mechanism: 'Set during enrollment or manually by administrators'
        },
        { 
          source: 'deviceOwnership', 
          target: 'policies', 
          type: 'influences', 
          description: 'Different policies applied based on ownership',
          details: 'Corporate devices typically receive stricter policies than personal devices',
          mechanism: 'Used in assignment filters and dynamic group membership'
        },
        { 
          source: 'devicePlatforms', 
          target: 'devices', 
          type: 'categorizes', 
          description: 'Identifies the device operating system',
          details: 'Windows, iOS/iPadOS, Android, macOS, etc.',
          mechanism: 'Detected during device enrollment'
        },
        { 
          source: 'devicePlatforms', 
          target: 'configurations', 
          type: 'determines', 
          description: 'Platform-specific configuration profiles',
          details: 'Different settings available per platform',
          mechanism: 'Platform-specific configuration profile types with unique capabilities'
        },
        { 
          source: 'devicePlatforms', 
          target: 'scripts', 
          type: 'determines', 
          description: 'Platform-specific script compatibility',
          details: 'PowerShell for Windows, Shell scripts for macOS',
          mechanism: 'Different script engines per platform'
        },
        { 
          source: 'termsOfUse', 
          target: 'users', 
          type: 'presented to', 
          description: 'Users must accept terms before access',
          details: 'Can include custom agreements, disclaimers, or policies',
          mechanism: 'Part of conditional access and compliance process'
        },
        { 
          source: 'shellScripts', 
          target: 'devices', 
          type: 'runs on', 
          description: 'Shell scripts execute on macOS devices',
          details: 'Provides macOS-specific management capabilities',
          mechanism: 'Delivered and executed by the Intune macOS agent'
        },
        { 
          source: 'notification', 
          target: 'adminRoles', 
          type: 'alerts', 
          description: 'Sends alerts to administrators',
          details: 'Notifies of important events or issues',
          mechanism: 'Email notifications and in-console alerts'
        },
        { 
          source: 'reporting', 
          target: 'dataWarehouse', 
          type: 'consumes', 
          description: 'Reports built from warehouse data',
          details: 'Historical reporting based on stored data',
          mechanism: 'Queries against OData endpoints'
        },
        { 
          source: 'reporting', 
          target: 'graphAPI', 
          type: 'accessible via', 
          description: 'Reports available through API',
          details: 'Custom reporting solutions can be built',
          mechanism: 'Report data accessible through Graph API endpoints'
        }
      ];

      // Category definitions with improved contrast
      const categories = [
        { id: 'core', name: 'Core Components', color: '#2563eb' },     // Deeper blue
        { id: 'admin', name: 'Administration', color: '#dc2626' },     // Brighter red
        { id: 'device', name: 'Device Management', color: '#16a34a' }, // Deeper green
        { id: 'compliance', name: 'Compliance & Access', color: '#ea580c' }, // Brighter orange
        { id: 'remediation', name: 'Scripts & Remediation', color: '#0ea5e9' }, // Brighter blue
        { id: 'api', name: 'APIs & Integration', color: '#9333ea' }    // Brighter purple
      ];

      // Create the force-directed graph visualization
      useEffect(() => {
        if (!svgRef.current || view !== 'diagram') return;
        
        // Filter nodes and links based on active layers
        const activeNodes = nodes.filter(node => 
          activeLayers.includes(node.category) ||
          (focusedNode && (
            node.id === focusedNode || 
            links.some(link => 
              (link.source === focusedNode && link.target === node.id) || 
              (link.target === focusedNode && link.source === node.id)
            )
          ))
        );
        
        const activeLinks = links.filter(link => 
          activeNodes.some(node => node.id === link.source) && 
          activeNodes.some(node => node.id === link.target) &&
          (!focusedNode || link.source === focusedNode || link.target === focusedNode)
        );
        
        // Update the width and height based on the container
        const width = svgRef.current.clientWidth;
        const height = svgRef.current.clientHeight;
        
        // Clear previous content
        d3.select(svgRef.current).selectAll("*").remove();
        
        const svg = d3.select(svgRef.current)
          .attr("viewBox", [0, 0, width, height])
          .attr("style", "max-width: 100%; height: 100%; background-color: #2c3e50;");
          
        // Add zoom capability
        const g = svg.append("g");
        
        svg.call(d3.zoom()
          .extent([[0, 0], [width, height]])
          .scaleExtent([0.5, 5])
          .on("zoom", (event) => {
            g.attr("transform", event.transform);
          }));
        
        // Create defs section for styling elements
        const defs = g.append("defs");
        
        // Create a force simulation with stronger forces for more structured layout
        const simulation = d3.forceSimulation(activeNodes)
          .force("link", d3.forceLink(activeLinks).id(d => d.id).distance(220).strength(0.9)) // Higher strength, more distance
          .force("charge", d3.forceManyBody().strength(-1500)) // Even stronger repulsion
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(50).strength(1)) // Maximum collision strength
          .force("x", d3.forceX(width / 2).strength(0.15)) // Stronger x-positioning
          .force("y", d3.forceY(height / 2).strength(0.15)) // Stronger y-positioning
          .alphaDecay(0.04); // Faster cooling for more stability
          
        // Create the links
        const linkElements = g.append("g")
          .attr("class", "links")
          .selectAll("path")
          .data(activeLinks)
          .join("path")
          .attr("class", "link")
          .attr("stroke", d => {
            // Match link color to source node category
            const sourceNode = nodes.find(n => n.id === d.source);
            const category = categories.find(c => c.id === sourceNode?.category);
            return category ? category.color : "#999";
          })
          .attr("stroke-width", 2)
          .attr("stroke-opacity", 0.8)
          .attr("fill", "none")
          .on("click", (event, d) => {
            setSelectedObject({ type: 'relationship', data: d });
            setShowRelationshipDetails(true);
            event.stopPropagation();
          })
          .on("mouseover", function() {
            d3.select(this).attr("stroke-width", 3).attr("stroke-opacity", 1);
          })
          .on("mouseout", function() {
            d3.select(this).attr("stroke-width", 2).attr("stroke-opacity", 0.8);
          });
          
        // Add direction indicators
        const directionIndicators = g.append("g")
          .selectAll("path")
          .data(activeLinks)
          .join("path")
          .attr("class", "direction-indicator")
          .attr("stroke", "#ffffff")
          .attr("stroke-width", 2)
          .attr("fill", "none");
          
        // Add text labels for links
        const linkLabels = g.append("g")
          .selectAll("text")
          .data(activeLinks)
          .join("text")
          .attr("class", "link-label")
          .attr("text-anchor", "middle")
          .attr("fill", "white")
          .attr("font-size", "12px")
          .attr("font-weight", "600")
          .attr("pointer-events", "none")
          .attr("stroke", "#111")
          .attr("stroke-width", "4")
          .attr("stroke-linejoin", "round")
          .attr("paint-order", "stroke")
          .attr("opacity", 0.95)
          .text(d => d.type);

        // Create the nodes
        const nodeElements = g.append("g")
          .selectAll("g")
          .data(activeNodes)
          .join("g")
          .attr("class", "node")
          .on("click", (event, d) => {
            setFocusedNode(focusedNode === d.id ? null : d.id);
            setSelectedObject({ type: 'node', data: d });
            setShowRelationshipDetails(false);
            event.stopPropagation();
          })
          .call(d3.drag()
            .on("start", dragStarted)
            .on("drag", dragging)
            .on("end", dragEnded));
        
        // Add circle for the node with fixed size
        nodeElements.append("circle")
          .attr("r", 45) // Fixed radius
          .attr("fill", d => {
            const category = categories.find(c => c.id === d.category);
            return category ? category.color : "#999";
          })
          .attr("stroke", d => focusedNode === d.id ? "#fff" : "#333")
          .attr("stroke-width", d => focusedNode === d.id ? 3 : 2)
          .attr("filter", "drop-shadow(0px 2px 3px rgba(0,0,0,0.2))");
        
        // Helper function to create wrapped text
        function addWrappedText(selection) {
          selection.each(function(d) {
            const text = d3.select(this);
            const words = d.name.split(/\s+/);
            
            // Clear existing content
            text.text(null);
            
            // Single word case
            if (words.length === 1) {
              text.append("tspan")
                .attr("x", 0)
                .attr("y", 0)
                .attr("dy", ".35em")
                .text(words[0]);
              return;
            }
            
            // For multi-words, split into two lines
            const midpoint = Math.ceil(words.length / 2);
            const line1 = words.slice(0, midpoint).join(" ");
            const line2 = words.slice(midpoint).join(" ");
            
            text.append("tspan")
              .attr("x", 0)
              .attr("y", -8)
              .attr("text-anchor", "middle")
              .text(line1);
            
            text.append("tspan")
              .attr("x", 0)
              .attr("y", 8)
              .attr("text-anchor", "middle")
              .text(line2);
          });
        }
        
        // Add text label with wrapping
        nodeElements.append("text")
          .attr("text-anchor", "middle")
          .attr("fill", "white")
          .attr("font-weight", "bold")
          .attr("font-size", "11px")
          .attr("stroke", "rgba(0,0,0,0.6)")
          .attr("stroke-width", "0.5px")
          .call(addWrappedText);
        
        // Update positions on simulation tick
        simulation.on("tick", () => {
          // Update link paths
          linkElements
            .attr("d", d => {
              // Get source and target positions
              const sx = d.source.x;
              const sy = d.source.y;
              const tx = d.target.x;
              const ty = d.target.y;
              
              // Calculate direction vector
              const dx = tx - sx;
              const dy = ty - sy;
              const len = Math.sqrt(dx * dx + dy * dy);
              
              // Normalize direction vector
              const nx = dx / len;
              const ny = dy / len;
              
              // Fixed circle radius
              const radius = 45;
              
              // Calculate end points at the edges of circles
              const sourceX = sx + nx * radius;
              const sourceY = sy + ny * radius;
              const targetX = tx - nx * radius;
              const targetY = ty - ny * radius;
              
              // Straight line from source edge to target edge
              return `M${sourceX},${sourceY}L${targetX},${targetY}`;
            });
          
          // Update directional indicators
          directionIndicators
            .attr("d", d => {
              const sx = d.source.x, sy = d.source.y;
              const tx = d.target.x, ty = d.target.y;
              
              // Calculate direction vector
              const dx = tx - sx, dy = ty - sy;
              const len = Math.sqrt(dx * dx + dy * dy);
              
              // Normalize
              const nx = dx / len, ny = dy / len;
              
              // Circle radius
              const radius = 45;
              
              // Endpoints at circle boundaries
              const sourceX = sx + nx * radius;
              const sourceY = sy + ny * radius;
              const targetX = tx - nx * radius;
              const targetY = ty - ny * radius;
              
              // Calculate midpoint for chevron
              const midX = (sourceX + targetX) / 2;
              const midY = (sourceY + targetY) / 2;
              
              // Create perpendicular vector for chevron
              const perpX = -ny;  // Perpendicular to direction
              const perpY = nx;
              
              // Chevron points: 8px wide, 8px long
              const chevronSize = 8;
              const backOffsetX = -nx * chevronSize;
              const backOffsetY = -ny * chevronSize;
              
              // Points for the chevron
              const p1x = midX + perpX * chevronSize/2 + backOffsetX;
              const p1y = midY + perpY * chevronSize/2 + backOffsetY;
              const p2x = midX;
              const p2y = midY;
              const p3x = midX - perpX * chevronSize/2 + backOffsetX;
              const p3y = midY - perpY * chevronSize/2 + backOffsetY;
              
              // Draw the chevron
              return `M${p1x},${p1y} L${p2x},${p2y} L${p3x},${p3y}`;
            });
          
          // Update link label positions
          linkLabels
            .attr("transform", d => {
              const dx = d.target.x - d.source.x;
              const dy = d.target.y - d.source.y;
              const angle = Math.atan2(dy, dx) * 180 / Math.PI;
              
              // Midpoint calculation accounting for node radius
              const nx = dx / Math.sqrt(dx*dx + dy*dy);
              const ny = dy / Math.sqrt(dx*dx + dy*dy);
              const radius = 45;
              
              const sourceX = d.source.x + nx * radius;
              const sourceY = d.source.y + ny * radius;
              const targetX = d.target.x - nx * radius;
              const targetY = d.target.y - ny * radius;
              
              const midX = (sourceX + targetX) / 2;
              const midY = (sourceY + targetY) / 2 - 20; // Higher offset for label
              
              // Maintain right-side up text
              const rotation = angle > 90 || angle < -90 ? angle + 180 : angle;
              
              return `translate(${midX},${midY}) rotate(${rotation})`;
            });
          
          // Update node positions
          nodeElements.attr("transform", d => `translate(${d.x},${d.y})`);
        });
        
        // Clear any focused node when clicking on background
        svg.on("click", () => {
          setFocusedNode(null);
          setSelectedObject(null);
        });
        
        // Function to handle dragging with fixed positions after release
        function dragStarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }
        
        function dragging(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }
        
        function dragEnded(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          // Don't release node position - keep it fixed where user dragged it
        }
      }, [activeLayers, focusedNode, view]);
      
      return (
        <div className="flex flex-col h-full w-full">
          {/* Header section */}
<div className="bg-gray-800 p-4 border-b border-gray-700 flex justify-between items-center">
  <div>
    <h2 className="text-xl font-bold text-white">Intune Ecosystem Explorer</h2>
    <p className="text-sm text-gray-400">Interactive visualization of component relationships and dependencies</p>
  </div>
  <a href="https://github.com/lindgrenar/" 
     target="_blank" 
     rel="noopener noreferrer" 
     className="text-gray-300 hover:text-white flex items-center transition-colors">
    <svg className="w-5 h-5 mr-1" viewBox="0 0 24 24" fill="currentColor">
      <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
    </svg>
    <span className="text-sm font-medium">lindgrenar · GitHub</span>
  </a>
</div>
          
          {/* View selector */}
          <div className="bg-gray-800 p-2 border-b border-gray-700 flex">
            <button 
              className={`px-3 py-1 rounded-md mr-2 ${view === 'diagram' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-200'}`}
              onClick={() => setView('diagram')}
            >
              Network Diagram
            </button>
            <button 
              className={`px-3 py-1 rounded-md ${view === 'list' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-200'}`}
              onClick={() => setView('list')}
            >
              Connection List
            </button>
          </div>
          
          <div className="visualization-container">
            {/* Main view area */}
            <div className="diagram-container">
              {/* Controls in a separate container */}
              <div className="controls-container">
                {/* Component selector */}
                <div className="mb-4">
                  <label className="block text-gray-300 mb-1 text-sm font-medium">Select Component:</label>
                  <select 
                    className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                    value={focusedNode || ''}
                    onChange={(e) => {
                      const selectedId = e.target.value;
                      setFocusedNode(selectedId || null);
                      if (selectedId) {
                        const node = nodes.find(n => n.id === selectedId);
                        setSelectedObject({ type: 'node', data: node });
                      }
                    }}
                  >
                    <option value="">All Components</option>
                    {nodes
                      .sort((a, b) => a.name.localeCompare(b.name))
                      .map(node => (
                        <option key={node.id} value={node.id}>
                          {node.name} ({categories.find(c => c.id === node.category)?.name})
                        </option>
                      ))
                    }
                  </select>
                </div>
                
                {/* Layer toggles */}
                <div className="mb-4 flex flex-wrap">
                  {categories.map(category => (
                    <label key={category.id} className="inline-flex items-center mr-4 mb-2">
                      <input
                        type="checkbox"
                        checked={activeLayers.includes(category.id)}
                        onChange={() => {
                          setActiveLayers(
                            activeLayers.includes(category.id)
                              ? activeLayers.filter(id => id !== category.id)
                              : [...activeLayers, category.id]
                          );
                        }}
                        className="mr-1"
                      />
                      <span style={{ color: category.color }} className="font-medium">{category.name}</span>
                    </label>
                  ))}
                </div>
              </div>
              
              {/* Visualization area */}
              {view === 'diagram' ? (
                <div className="svg-container">
                  <svg ref={svgRef} width="100%" height="100%"></svg>
                </div>
              ) : (
                <div className="list-view-container">
                  {/* List view of all relationships grouped by source */}
                  {Object.entries(
                    links
                      .filter(link => 
                        activeLayers.includes(nodes.find(n => n.id === link.source)?.category) && 
                        activeLayers.includes(nodes.find(n => n.id === link.target)?.category) &&
                        (!focusedNode || link.source === focusedNode || link.target === focusedNode)
                      )
                      .reduce((acc, link) => {
                        const sourceName = nodes.find(n => n.id === link.source)?.name || link.source;
                        if (!acc[sourceName]) acc[sourceName] = [];
                        acc[sourceName].push(link);
                        return acc;
                      }, {})
                  ).map(([sourceName, sourceLinks]) => (
                    <div key={sourceName} className="mb-4">
                      <h3 className="text-lg font-bold mb-2 text-gray-300 border-b border-gray-700 pb-1">{sourceName}</h3>
                      {sourceLinks.map((link, index) => (
                        <div 
                          key={index} 
                          className={`p-2 mb-2 border rounded cursor-pointer ${
                            selectedObject?.type === 'relationship' && selectedObject.data === link 
                              ? 'bg-blue-900 border-blue-500 shadow' 
                              : 'bg-gray-700 hover:bg-gray-600 border-gray-600'
                          }`}
                          onClick={() => {
                            setSelectedObject({ type: 'relationship', data: link });
                            setShowRelationshipDetails(true);
                          }}
                        >
                          <div className="flex items-center">
                            <span className="font-bold mr-2" style={{ 
                              color: categories.find(c => 
                                c.id === nodes.find(n => n.id === link.source)?.category
                              )?.color 
                            }}>
                              {nodes.find(n => n.id === link.source)?.name}
                            </span>
                            <span className="font-medium mx-1 bg-blue-800 text-white px-2 py-0.5 rounded text-xs">
                              {link.type}
                            </span>
                            <span className="mx-1 text-gray-500">→</span>
                            <span className="font-bold" style={{ 
                              color: categories.find(c => 
                                c.id === nodes.find(n => n.id === link.target)?.category
                              )?.color 
                            }}>
                              {nodes.find(n => n.id === link.target)?.name}
                            </span>
                          </div>
                          <p className="text-sm text-gray-300 mt-1">{link.description}</p>
                        </div>
                      ))}
                    </div>
                  ))}
                </div>
              )}
            </div>
            
            {/* Details panel */}
            <div className="details-panel">
              {selectedObject ? (
                <div>
                  {selectedObject.type === 'node' ? (
                    // Node details
                    <div>
                      <h3 className="text-lg font-bold mb-2 text-white">{selectedObject.data.name}</h3>
                      <div 
                        className="inline-block px-2 py-1 rounded text-xs text-white mb-3"
                        style={{ backgroundColor: categories.find(c => c.id === selectedObject.data.category)?.color }}
                      >
                        {categories.find(c => c.id === selectedObject.data.category)?.name}
                      </div>
                      <p className="mb-4 text-gray-300">{selectedObject.data.description}</p>
                      
                      <h4 className="font-bold text-sm uppercase text-gray-400 mt-4 mb-2">Relationships</h4>
                      
                      {/* Outgoing relationships */}
                      {links.filter(link => link.source === selectedObject.data.id).length > 0 && (
                        <div className="mb-3">
                          <h5 className="font-medium text-sm text-gray-300">Outgoing:</h5>
                          <ul className="ml-4 text-sm">
                            {links
                              .filter(link => link.source === selectedObject.data.id)
                              .map((link, index) => (
                                <li key={index} className="mb-1 text-gray-300">
                                  <span className="font-medium text-blue-400">{link.type}</span>{' '}
                                  <span style={{ 
                                    color: categories.find(c => 
                                      c.id === nodes.find(n => n.id === link.target)?.category
                                    )?.color 
                                  }}>
                                    {nodes.find(n => n.id === link.target)?.name}
                                  </span>
                                </li>
                              ))
                            }
                          </ul>
                        </div>
                      )}
                      
                      {/* Incoming relationships */}
                      {links.filter(link => link.target === selectedObject.data.id).length > 0 && (
                        <div>
                          <h5 className="font-medium text-sm text-gray-300">Incoming:</h5>
                          <ul className="ml-4 text-sm">
                            {links
                              .filter(link => link.target === selectedObject.data.id)
                              .map((link, index) => (
                                <li key={index} className="mb-1 text-gray-300">
                                  <span style={{ 
                                    color: categories.find(c => 
                                      c.id === nodes.find(n => n.id === link.source)?.category
                                    )?.color 
                                  }}>
                                    {nodes.find(n => n.id === link.source)?.name}
                                  </span>{' '}
                                  <span className="font-medium text-blue-400">{link.type}</span>
                                </li>
                              ))
                            }
                          </ul>
                        </div>
                      )}
                    </div>
                  ) : (
                    // Relationship details
                    <div>
                      <div className="flex items-center mb-3">
                        <span 
                          className="font-bold"
                          style={{ 
                            color: categories.find(c => 
                              c.id === nodes.find(n => n.id === selectedObject.data.source)?.category
                            )?.color 
                          }}
                        >
                          {nodes.find(n => n.id === selectedObject.data.source)?.name}
                        </span>
                        <span className="mx-2 text-gray-500">→</span>
                        <span 
                          className="font-bold"
                          style={{ 
                            color: categories.find(c => 
                              c.id === nodes.find(n => n.id === selectedObject.data.target)?.category
                            )?.color 
                          }}
                        >
                          {nodes.find(n => n.id === selectedObject.data.target)?.name}
                        </span>
                      </div>
                      
                      <div className="mb-3">
                        <h4 className="font-bold text-sm uppercase text-gray-400">Relationship Type</h4>
                        <p className="text-white">{selectedObject.data.type}</p>
                      </div>
                      
                      <div className="mb-3">
                        <h4 className="font-bold text-sm uppercase text-gray-400">Description</h4>
                        <p className="text-gray-300">{selectedObject.data.description}</p>
                      </div>
                      
                      {showRelationshipDetails && (
                        <>
                          <div className="mb-3">
                            <h4 className="font-bold text-sm uppercase text-gray-400">Details</h4>
                            <p className="text-gray-300">{selectedObject.data.details}</p>
                          </div>
                          
                          <div>
                            <h4 className="font-bold text-sm uppercase text-gray-400">How It Works</h4>
                            <p className="text-gray-300">{selectedObject.data.mechanism}</p>
                          </div>
                        </>
                      )}
                      
                      <button
                        className="mt-3 text-blue-400 text-sm font-medium hover:text-blue-300"
                        onClick={() => setShowRelationshipDetails(!showRelationshipDetails)}
                      >
                        {showRelationshipDetails ? 'Show less' : 'Show more details'}
                      </button>
                    </div>
                  )}
                </div>
              ) : (
                // No selection state
                <div className="text-center text-gray-400 py-8">
                  <p>Select a component or connection to view details</p>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<IntuneObjectMap />);
  </script>
</body>
</html>